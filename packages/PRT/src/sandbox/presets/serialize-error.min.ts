export const serializeErrorScript = `
let list=[EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError,globalThis.DOMException,globalThis.AssertionError,globalThis.SystemError,].filter(Boolean).map(r=>[r.name,r]),errorConstructors=new Map(list);class NonError extends Error{name="NonError";constructor(r){super(NonError._prepareSuperMessage(r))}static _prepareSuperMessage(r){try{return JSON.stringify(r)}catch{return String(r)}}}let commonProperties=[{property:"name",enumerable:!1},{property:"message",enumerable:!1},{property:"stack",enumerable:!1},{property:"code",enumerable:!0},{property:"cause",enumerable:!1},],toJsonWasCalled=new WeakSet,toJSON=r=>{toJsonWasCalled.add(r);let e=r.toJSON();return toJsonWasCalled.delete(r),e},getErrorConstructor=r=>errorConstructors.get(r)??Error,destroyCircular=({from:r,seen:e,to:o,forceEnumerable:t,maxDepth:n,depth:i,useToJSON:s,serialize:a})=>{if(!o){if(Array.isArray(r))o=[];else if(!a&&isErrorLike(r)){let u=getErrorConstructor(r.name);o=new u}else o={}}if(e.push(r),i>=n)return o;if(s&&"function"==typeof r.toJSON&&!toJsonWasCalled.has(r))return toJSON(r);let l=r=>destroyCircular({from:r,seen:[...e],forceEnumerable:t,maxDepth:n,depth:i,useToJSON:s,serialize:a});for(let[c,f]of Object.entries(r)){if(f&&f instanceof Uint8Array&&"Buffer"===f.constructor.name){o[c]="[object Buffer]";continue}if(null!==f&&"object"==typeof f&&"function"==typeof f.pipe){o[c]="[object Stream]";continue}if("function"!=typeof f){if(!f||"object"!=typeof f){try{o[c]=f}catch{}continue}if(!e.includes(r[c])){i++,o[c]=l(r[c]);continue}o[c]="[Circular]"}}for(let{property:p,enumerable:m}of commonProperties)void 0!==r[p]&&null!==r[p]&&Object.defineProperty(o,p,{value:isErrorLike(r[p])?l(r[p]):r[p],enumerable:!!t||m,configurable:!0,writable:!0});return o};function serializeError(r,e={}){let{maxDepth:o=Number.POSITIVE_INFINITY,useToJSON:t=!0}=e;return"object"==typeof r&&null!==r?destroyCircular({from:r,seen:[],forceEnumerable:!0,maxDepth:o,depth:0,useToJSON:t,serialize:!0}):"function"==typeof r?\`[Function: \${r.name||"anonymous"}]\`:r}function deserializeError(r,e={}){let{maxDepth:o=Number.POSITIVE_INFINITY}=e;if(r instanceof Error)return r;if(isMinimumViableSerializedError(r)){let t=getErrorConstructor(r.name);return destroyCircular({from:r,seen:[],to:new t,maxDepth:o,depth:0,serialize:!1})}return new NonError(r)}function isErrorLike(r){return Boolean(r)&&"object"==typeof r&&"name"in r&&"message"in r&&"stack"in r}function isMinimumViableSerializedError(r){return Boolean(r)&&"object"==typeof r&&"message"in r&&!Array.isArray(r)}window.isErrorLike=isErrorLike,window.serializeError=serializeError,window.deserializeError=deserializeError;window.errorConstructors=errorConstructors;
`;
